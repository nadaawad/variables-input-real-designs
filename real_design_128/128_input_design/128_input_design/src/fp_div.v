//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ????? ?????? 13 2013 21:06:37
//
//      Input file      : 
//      Component name  : fp_div
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module FP_div(FP_A, FP_B, clk, ce, FP_Z);
   parameter         K = 32;
   parameter         P = 24;
   parameter         E = 8;
   input [K-1:0]     FP_A;
   input [K-1:0]     FP_B;
   input             clk;
   input             ce;
   output [K-1:0]    FP_Z;
   reg [K-1:0]       FP_Z;
   
   
   parameter [K-1:0] ZEROS = 1'b0;
   parameter [K-1:0] ONES = 32'hffffffff;
   parameter [E-1:0] BIAS = {1'b0, ONES[E - 2:0]};
   parameter         PBITS = P + 3;
   
   reg [K-1:0]       A_int;
   reg [K-1:0]       B_int;
   reg [K-1:0]       FP_Z_int;
   wire [E-1:0]      exp_A;
   wire [E-1:0]      exp_B;
   wire [P-1:0]      frac_A;
   wire [P-1:0]      frac_B;
   wire              sign_A;
   wire              sign_B;
   
   wire              expA_FF;
   wire              expB_FF;
   wire              expA_Z;
   wire              expB_Z;
   wire              fracA_Z;
   wire              fracB_Z;
   wire [E:0]        exp_noBIAS;
   wire [E:0]        exp_Biased;
   wire [E:0]        exp_Biased_Norm;
   
   wire              isNaN_A;
   wire              isNaN_B;
   wire              isInf_A;
   wire              isInf_B;
   wire              isZero_A;
   wire              isZero_B;
   wire              isNaN;
   wire              isInf;
   wire              isZero;
   wire              sign;
   
   wire [PBITS-1:0]  frac_div;
   wire [PBITS-1:0]  frac_div_shifted;
   wire [PBITS-2:0]  fr_sh;
   wire [P-2:0]      frac_final;
   wire              underflow;
   wire              overflow;
   wire [E-1:0]      exp_final;
   
   wire              sticky_bit;
   wire              div_by_zero;
   
   
   always @(posedge clk)
      
      begin
         if (ce == 1'b1)
         begin
            A_int <= FP_A;
            B_int <= FP_B;
         end
      end
   
   assign sign_A = A_int[K - 1];
   assign sign_B = B_int[K - 1];
   assign exp_A = A_int[K - 2:K - E - 1];
   assign exp_B = B_int[K - 2:K - E - 1];
   assign frac_A = {1'b1, A_int[P - 2:0]};
   assign frac_B = {1'b1, B_int[P - 2:0]};
   
   assign expA_FF = (A_int[K - 2:K - E - 1] == ONES[K - 2:K - E - 1]) ? 1'b1 : 
                    1'b0;
   assign expB_FF = (B_int[K - 2:K - E - 1] == ONES[K - 2:K - E - 1]) ? 1'b1 : 
                    1'b0;
   assign expA_Z = (A_int[K - 2:K - E - 1] == ZEROS[K - 2:K - E - 1]) ? 1'b1 : 
                   1'b0;
   assign expB_Z = (B_int[K - 2:K - E - 1] == ZEROS[K - 2:K - E - 1]) ? 1'b1 : 
                   1'b0;
   assign fracA_Z = (A_int[P - 2:0] == ZEROS[P - 2:0]) ? 1'b1 : 
                    1'b0;
   assign fracB_Z = (B_int[P - 2:0] == ZEROS[P - 2:0]) ? 1'b1 : 
                    1'b0;
   
   assign isNaN_A = expA_FF & ((~fracA_Z));
   assign isNaN_B = expB_FF & ((~fracB_Z));
   assign isInf_A = expA_FF;
   assign isInf_B = expB_FF;
   assign isZero_A = expA_Z & fracA_Z;
   assign isZero_B = expB_Z & fracB_Z;
   
   assign div_by_zero = expB_Z;
   assign isNaN = isNaN_A | isNaN_B;
   assign isInf = isInf_A | isInf_B | div_by_zero;
   assign isZero = isZero_A & (~isZero_B);
   
   assign exp_noBIAS = ({1'b0, exp_A}) - ({1'b0, exp_B});
   assign exp_Biased = exp_noBIAS + ({1'b0, BIAS});
   assign sign = sign_A ^ sign_B;
   
   
   div_nr_wsticky #(P,PBITS) a_div(.A(frac_A), .B(frac_B), .Q(frac_div), .sticky(sticky_bit));
   
   assign frac_div_shifted = (frac_div[PBITS - 1] == 1'b0) ? {frac_div[PBITS - 2:0], 1'b0} : 
                             frac_div;
   
   assign exp_Biased_Norm = (frac_div[PBITS - 1] == 1'b0) ? exp_Biased - 1 : 
                            exp_Biased;
   assign exp_final = exp_Biased_Norm[E - 1:0];
   assign overflow = (((exp_Biased_Norm[E:E - 1] == 2'b10) | (exp_Biased_Norm[E:0] == {1'b0, ONES[E - 1:0]}))) ? 1'b1 : 
                     1'b0;
   assign underflow = (((exp_Biased_Norm[E:E - 1] == 2'b11) | (exp_Biased_Norm[E - 1:0] == ZEROS[E - 1:0]))) ? 1'b1 : 
                      1'b0;
   
   assign fr_sh = frac_div_shifted[PBITS - 2:0];
   assign frac_final = ((fr_sh[2] == 1'b1 & (sticky_bit == 1'b1 | fr_sh[0] == 1'b1 | fr_sh[1] == 1'b1))) ? fr_sh[PBITS - 2:PBITS - P] + 1 : 
                       (((sticky_bit == 1'b1) & (fr_sh[2:0] == 3'b100) & (fr_sh[3] == 1'b1))) ? fr_sh[PBITS - 2:PBITS - P] + 1 : 
                       fr_sh[PBITS - 2:PBITS - P];
   
   
   always @(sign or isNaN or isInf or isZero or exp_final or frac_final or underflow or overflow)
   begin: packing
      FP_Z_int[K - 1] <= sign;
      if (isNaN == 1'b1)
      begin
         FP_Z_int[K - 2:P - 1] <= ONES[E - 1:0];
         FP_Z_int[P - 2:0] <= {1'b1, ZEROS[P - 3:0]};
      end
      else if ((isInf == 1'b1) | (overflow == 1'b1))
      begin
         FP_Z_int[K - 2:P - 1] <= ONES[E - 1:0];
         FP_Z_int[P - 2:0] <= ZEROS[P - 2:0];
      end
      else if ((isZero == 1'b1) | (underflow == 1'b1))
      begin
         FP_Z_int[K - 2:P - 1] <= ZEROS[E - 1:0];
         FP_Z_int[P - 2:0] <= ZEROS[P - 2:0];
      end
      else
      begin
         FP_Z_int[K - 2:P - 1] <= exp_final;
         FP_Z_int[P - 2:0] <= frac_final;
      end
   end
   
   
   always @(posedge clk)
   begin: final_reg
      
      begin
         if (ce == 1'b1)
            FP_Z <= FP_Z_int;
      end
   end
   
endmodule
