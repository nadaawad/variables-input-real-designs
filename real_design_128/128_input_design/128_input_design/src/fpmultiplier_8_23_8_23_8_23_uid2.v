//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Mon Apr 21 2014 01:17:19
//
//      Input file      : 
//      Component name  : fpmultiplier_8_23_8_23_8_23_uid2
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//                           IntAdder_42_f300_uid15
//                    (IntAdderAlternative_42_f300_uid19)
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Bogdan Pasca, Florent de Dinechin (2008-2010)
//------------------------------------------------------------------------------
// Pipeline depth: 0 cycles

//Alternative

//------------------------------------------------------------------------------
//               IntMultiplier_UsingDSP_24_24_48_unsigned_uid4
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Florent de Dinechin, Kinga Illyes, Bogdan Popa, Bogdan Pasca, 2012
//------------------------------------------------------------------------------
// Pipeline depth: 1 cycles

// Beginning of code generated by BitHeap::generateCompressorVHDL
// code generated by BitHeap::generateSupertileVHDL()
//--------------Synchro barrier, entering cycle 0----------------
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
//--------------Synchro barrier, entering cycle 0----------------
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
// cycle= 0 cp= 2.387e-09
//--------------Synchro barrier, entering cycle 0----------------

// Adding the constant bits

//--------------Synchro barrier, entering cycle 0----------------
//--------------Synchro barrier, entering cycle 0----------------
//--------------Synchro barrier, entering cycle 1----------------
// pipelineDepth=0 maxInDelay=0
//--------------Synchro barrier, entering cycle 0----------------
// already compressed
// concatenate all the compressed chunks
//--------------Synchro barrier, entering cycle 1----------------
// End of code generated by BitHeap::generateCompressorVHDL

//------------------------------------------------------------------------------
//                           IntAdder_33_f300_uid23
//                     (IntAdderClassical_33_f300_uid25)
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Bogdan Pasca, Florent de Dinechin (2008-2010)
//------------------------------------------------------------------------------
// Pipeline depth: 1 cycles

//Classical
//--------------Synchro barrier, entering cycle 1----------------

//------------------------------------------------------------------------------
//                      FPMultiplier_8_23_8_23_8_23_uid2
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Bogdan Pasca, Florent de Dinechin 2008-2011
//------------------------------------------------------------------------------
// Pipeline depth: 2 cycles

module FPMultiplier_8_23_8_23_8_23_uid2(clk, rst, X, Y, R);
   input             clk;
   input             rst;
   input [8+23+2:0]  X;
   input [8+23+2:0]  Y;
   output [8+23+2:0] R;
   
   
   wire              sign;
   reg               sign_d1;
   reg               sign_d2;
   wire [7:0]        expX;
   wire [7:0]        expY;
   wire [9:0]        expSumPreSub;
   wire [9:0]        bias;
   wire [9:0]        expSum;
   reg [9:0]         expSum_d1;
   wire [23:0]       sigX;
   wire [23:0]       sigY;
   wire [47:0]       sigProd;
   wire [3:0]        excSel;
   wire [1:0]        exc;
   reg [1:0]         exc_d1;
   reg [1:0]         exc_d2;
   wire              norm;
   wire [9:0]        expPostNorm;
   wire [47:0]       sigProdExt;
   wire [32:0]       expSig;
   wire              sticky;
   wire              guard;
   wire              round;
   wire [32:0]       expSigPostRound;
   wire [1:0]        excPostNorm;
   wire [1:0]        finalExc;
   
   always @(posedge clk)
      
      begin
         sign_d1 <= sign;
         sign_d2 <= sign_d1;
         expSum_d1 <= expSum;
         exc_d1 <= exc;
         exc_d2 <= exc_d1;
      end
   assign sign = X[31] ^ Y[31];
   assign expX = X[30:23];
   assign expY = Y[30:23];
   assign expSumPreSub = ({2'b00, expX}) + ({2'b00, expY});
   assign bias = 10'd127;
   assign expSum = expSumPreSub - bias;
   //--------------Synchro barrier, entering cycle 0----------------
   assign sigX = {1'b1, X[22:0]};
   assign sigY = {1'b1, Y[22:0]};
   		// pipelineDepth=1 maxInDelay=0
   IntMultiplier_UsingDSP_24_24_48_unsigned_uid4 SignificandMultiplication(.clk(clk), .rst(rst), .R(sigProd), .X(sigX), .Y(sigY));
   //--------------Synchro barrier, entering cycle 1----------------
   //--------------Synchro barrier, entering cycle 0----------------
   assign excSel = {X[33:32], Y[33:32]};
   assign exc = (excSel == 4'b0000 || excSel == 4'b0001 || excSel == 4'b0100) ? 2'b00 : 
                (excSel == 4'b0101) ? 2'b01 : 
                (excSel == 4'b0110 || excSel == 4'b1001 || excSel == 4'b1010) ? 2'b10 : 
                2'b11;
   //--------------Synchro barrier, entering cycle 1----------------
   assign norm = sigProd[47];
   // exponent update
   assign expPostNorm = expSum_d1 + ({9'b000000000, norm});
   //--------------Synchro barrier, entering cycle 1----------------
   // significand normalization shift
   assign sigProdExt = (norm == 1'b1) ? {sigProd[46:0], 1'b0} : 
                       {sigProd[45:0], 2'b00};
   assign expSig = {expPostNorm, sigProdExt[47:25]};
   assign sticky = sigProdExt[24];
   assign guard = (sigProdExt[23:0] == 24'b000000000000000000000000) ? 1'b0 : 
                  1'b1;
   assign round = sticky & ((guard & (~(sigProdExt[25]))) | (sigProdExt[25]));
   		// pipelineDepth=1 maxInDelay=2.80116e-09
   IntAdder_33_f300_uid23 RoundingAdder(.clk(clk), .rst(rst), .Cin(round), .R(expSigPostRound), .X(expSig), .Y(33'b000000000000000000000000000000000));
   //--------------Synchro barrier, entering cycle 2----------------
   assign excPostNorm = (expSigPostRound[32:31] == 2'b00) ? 2'b01 : 
                        (expSigPostRound[32:31] == 2'b01) ? 2'b10 : 
                        (expSigPostRound[32:31] == 2'b11 || expSigPostRound[32:31] == 2'b10) ? 2'b00 : 
                        2'b11;
   assign finalExc = (exc_d2 == 2'b11 || exc_d2 == 2'b10 || exc_d2 == 2'b00) ? exc_d2 : 
                     excPostNorm;
   assign R = {finalExc, sign_d2, expSigPostRound[30:0]};
   
endmodule
